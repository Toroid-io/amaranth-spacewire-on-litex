use std::{env, fs};
use std::io::Write;
use std::path::PathBuf;

extern crate svd2rust;

fn main() {
    // Get regions from litex output
    let build_dir = PathBuf::from(env::var("BUILD_DIR").unwrap());
    fs::copy(build_dir.join("software/include/generated/regions.ld"), "memory.x").unwrap();

    let aliases = fs::read_to_string("memory_aliases")
        .expect("svd file wasn't valid utf8");

    let mut memx = fs::OpenOptions::new()
        .append(true)
        .open("memory.x")
        .unwrap();

    memx.write(aliases.as_bytes()).unwrap();

    // Put the memory definitions somewhere the linker can find it
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    println!("cargo:rustc-link-search={}", out_dir.display());

    fs::copy("memory.x", out_dir.join("memory.x")).unwrap();
    println!("cargo:rerun-if-changed=memory.x");

    // If the svd file changes, rebuild this crate
    let svd_file = format!("{}/csr.svd", build_dir.display());
    println!("cargo:rerun-if-changed={}", svd_file);
    let svd = fs::read_to_string(svd_file)
        .expect("svd file wasn't valid utf8");


    // Generate the svd file to a string in RAM
    let mut config : svd2rust::Config = svd2rust::Config::default();
    config.target = svd2rust::Target::RISCV;
    let pac_file = svd2rust::generate(&svd, &config)
        .expect("couldn't generate file with svd2rust");

    // This appears to be what they do inside svd2rust:main.rs
    let lib_rs = pac_file.lib_rs.replace("] ", "]\n");

    // These strings are generated by svd2rust.  Remove them to silence warnings.
    let bad_strings = [
        "# ! [ deny ( legacy_directory_ownership ) ]",
        "# ! [ deny ( plugin_as_library ) ]",
        "# ! [ deny ( safe_extern_statics ) ]",
        "# ! [ deny ( unions_with_drop_fields ) ]",
        "#![no_main]",
        "# ! [no_std]",
    ];

    // Generate the output PAC file
    let mut out_file = fs::File::create("src/pac.rs").expect("couldn't open output file");
    for line in lib_rs.lines() {
        if bad_strings.contains(&line) {
            println!("Found bad string, skipping");
            continue;
        }
        out_file
            .write(line.as_bytes())
            .expect("couldn't write line to pac.rs");
        out_file
            .write(b"\n")
            .expect("couldn't write line ending to pac.rs");
    }
}
